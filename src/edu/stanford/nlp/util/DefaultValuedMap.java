package edu.stanford.nlp.util;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.Collection;

import edu.stanford.nlp.stats.Counter;
import edu.stanford.nlp.stats.ClassicCounter;

/**
 * Map which returns a default value when asked for a value for
 * a key with no entry. It allows arbitrarily many dimensional maps. For an example, see
 * the main method, or the following code:
 *
 * <CODE>
 *   Factory<String> factory = new Factory<String>() {
 *     public String create() {
 *       return "hello world";
 *     }};
 *   DefaultValuedMap<String,String> dvm1 = new DefaultValuedMap<String,String>(factory);
 *   DefaultValuedMap<Integer,DefaultValuedMap<String,String>> dvm2 = dvm1.asDefault();
 *   DefaultValuedMap<String,DefaultValuedMap<Integer,DefaultValuedMap<String,String>>> dvm3 = dvm2.asDefault();
 * </CODE>
 *
 * @author Jenny Finkel
 * @author Steven Bethard
 */
public class DefaultValuedMap<K,V> implements Map<K,V>, Serializable {

  private static final long serialVersionUID = -4333026121894016524L;

  private Factory<? extends V> factory;
  private Map<K,V> map;

  public DefaultValuedMap(Factory<? extends V> factory) {
    this.factory = factory;
    this.map = new HashMap<K,V>();
  }

  /**
   * Create a map whose values default to empty ArrayLists.
   *
   * @param <K> The type of the keys in the map.
   * @param <V> The type of the items of the lists.
   * @return The new map.
   */
  public static <K, V> DefaultValuedMap<K, List<V>> arrayListValuedMap() {
    return new DefaultValuedMap<K, List<V>>(new Factory<ArrayList<V>>() {
      private static final long serialVersionUID = 2116307492728216010L;
      public ArrayList<V> create() {
        return new ArrayList<V>();
      }
    });
  }

  /**
   * Create a map whose values default to empty HashSets.
   *
   * @param <K> The type of the keys of the map.
   * @param <V> The type of the items in the sets.
   * @return The new map.
   */
  public static <K, V> DefaultValuedMap<K, Set<V>> hashSetValuedMap() {
    return new DefaultValuedMap<K, Set<V>>(new Factory<HashSet<V>>() {
      private static final long serialVersionUID = 2350514308926703021L;
      public HashSet<V> create() {
        return new HashSet<V>();
      }
    });
  }

  /**
   * Create a map whose values are HashMaps (a two-dimensional map).
   *
   * @param <K1> The type of the first key.
   * @param <K2> The type of the second key.
   * @param <V>  The type of the value.
   * @return The new map.
   */
  public static <K1, K2, V> DefaultValuedMap<K1, Map<K2, V>> hashMapValuedMap() {
    return new DefaultValuedMap<K1, Map<K2,V>>(new Factory<HashMap<K2, V>>() {
      private static final long serialVersionUID = -1503512462477559866L;
      public HashMap<K2, V> create() {
        return new HashMap<K2, V>();
      }
    });
  }

  /**
   * Create a map whose values default to empty ClassicCounters.
   *
   * @param <K> The type of the keys of the map.
   * @param <V> The type of the items being counted.
   * @return The new map.
   */
  public static <K, V> DefaultValuedMap<K, Counter<V>> counterValuedMap() {
    return new DefaultValuedMap<K, Counter<V>>(new Factory<ClassicCounter<V>>() {
      private static final long serialVersionUID = -1256126453217082137L;
      public ClassicCounter<V> create() {
        return new ClassicCounter<V>();
      }
    });
  }

  /**
   * Create a map whose values are generated by the factory of this DefaultValuedMap.
   *
   * @param <K2> The type of the keys of the new map.
   * @return The new map.
   */
  public <K2> DefaultValuedMap<K2, DefaultValuedMap<K, V>> asDefault() {
    return new DefaultValuedMap<K2, DefaultValuedMap<K, V>>(this.factory());
  }

  public void clear() {
    map.clear();
  }

  public boolean containsKey(Object key) {
    return map.containsKey(key);
  }

  public boolean containsValue(Object value) {
    return map.containsValue(value);
  }

  public Set<Map.Entry<K,V>> entrySet() {
    return map.entrySet();
  }

  @Override
  public boolean equals(Object o) {
    return map.equals(o);
  }

  public V get(Object key) {
    V v = map.get(key);
    if (v == null) {
      v = factory.create();
      map.put(ErasureUtils.<K>uncheckedCast(key), v);
    }
    return v;
  }

  @Override
  public int hashCode() {
    return map.hashCode();
  }

  public boolean isEmpty() {
    return map.isEmpty();
  }

  public Set<K> keySet() {
    return map.keySet();
  }

  public V put(K key, V value) {
    return map.put(key, value);
  }

  public void putAll(Map<? extends K, ? extends V> t) {
    map.putAll(t);
  }

  public V remove(Object key) {
    return map.remove(key);
  }

  public int size() {
    return map.size();
  }

  public Collection<V> values() {
    return map.values();
  }

  public Factory<DefaultValuedMap<K,V>> factory() {
    return new Factory<DefaultValuedMap<K,V>> (){
      private static final long serialVersionUID = 1L;

      public DefaultValuedMap<K,V> create() {
        return new DefaultValuedMap<K,V>(factory);
      }
    };
  }


  public static class MapFactory<K,V> implements Factory<Map<K,V>> {
    private static final long serialVersionUID = 1L;

    public Map<K,V> create() {
      return new HashMap<K,V>();
    }

  }


  public static void main(String[] args) {

    Factory<String> sf = new Factory<String>() {
      private static final long serialVersionUID = 1L;

      public String create() {
        return "hello world";
      }
    };

    DefaultValuedMap<String,String> dvm = new DefaultValuedMap<String, String>(sf);
    // Screw. I think this is a bug, but it's a main method
    @SuppressWarnings("unchecked")
    DefaultValuedMap<String,Map<String,String>> dvm1 = new DefaultValuedMap(dvm.factory());
    DefaultValuedMap<String,DefaultValuedMap<String,Map<String,String>>> dvm2 = new DefaultValuedMap<String, DefaultValuedMap<String, Map<String, String>>>(dvm1.factory());

    System.err.println(dvm2.get("hello").get("world").get("."));

    dvm2.get("hello").get("world").put("blah", "foobar");

    System.err.println(dvm2.get("hello").get("world").values());
  }

}