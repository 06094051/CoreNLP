package edu.stanford.nlp.util;

import java.math.BigInteger;
import java.util.Arrays;
import java.util.Iterator;
import java.util.NoSuchElementException;


/**
 * Generates successive permutations of n consecutive integers.
 * <p>
 * Example:
 * [0, 1, 2]
 * [0, 2, 1]
 * [1, 0, 2]
 * [1, 2, 0]
 * [2, 0, 1]
 * [2, 1, 0]
 *
 * @author Aria Haghighi
 * @author sbills (added documentation)
 * @author wcmac (added main method)
 * @author Christopher Manning. Made support Iterable
 */
public class PermutationGenerator implements Iterator<int[]> {

  private int[] a;
  private BigInteger numLeft;
  private BigInteger total;

  /**
   * Constructs permutation generator. WARNING: Don't make n too large.
   * Recall that the number of permutations is n!
   * which can be very large, even when n is as small as 20 --
   * 20! = 2,432,902,008,176,640,000 and
   * 21! is too big to fit into a Java long, which is
   * why we use BigInteger instead.
   *
   * @param n The number of elements to permute
   */
  public PermutationGenerator(int n) {
    if (n < 1) {
      throw new IllegalArgumentException("n must be positive");
    }
    a = new int[n];
    total = getFactorial(n);
    reset();
  }

  /**
   * Reset the permutation generator.
   */
  public final void reset() {
    for (int i = 0; i < a.length; i++) {
      a[i] = i;
    }
    numLeft = BigInteger.ZERO.add(total);
  }

  /**
   * @return number of permutations not yet generated
   */
  public BigInteger getNumLeft() {
    return numLeft;
  }

  /**
   * @return total number of permutations
   */
  public BigInteger getTotal() {
    return total;
  }

  /**
   * @return Are there more permutations?
   */
  public boolean hasNext() {
    return numLeft.compareTo(BigInteger.ZERO) == 1;
  }


  /**
   * Generates the next permutation.  A new array is created to store the
   * permutation, so it is safe to simultaneously work with multiple
   * permutations generated by this method.  If you only ever work
   * with one permutation at a time, it is more efficient to use
   * {@code getNext()} instead.
   * @see #getNext()
   * @return next permutation (independent)
   */
  public int[] next() {
    if (numLeft.compareTo(BigInteger.ZERO) < 1) {
      throw new NoSuchElementException();
    }
    int[] copy = new int[a.length];
    System.arraycopy(getNext(), 0, copy, 0, a.length);
    return copy;
  }

  /** Not supported by a permutation generator. */
  public void remove() {
    throw new UnsupportedOperationException();
  }
  
  /**
   * Generates the next permutation.  Note that the array reference that
   * is returned is shared across all calls to {@code getNext()}; if
   * you want to work with multiple permutations at a time, use
   * {@code getNextAsCopy()} instead.
   * @see #next()
   * @return next permutation (shared)
   */
  /* algorithm from Rosen p. 284 */
  public int[] getNext() {
    if (numLeft.equals(total)) {
      numLeft = numLeft.subtract(BigInteger.ONE);
      return a;
    }

    int temp;

    // Find largest index j with a[j] < a[j+1]

    int j = a.length - 2;
    while (a[j] > a[j + 1]) {
      j--;
    }

    // Find index k such that a[k] is smallest integer
    // greater than a[j] to the right of a[j]

    int k = a.length - 1;
    while (a[j] > a[k]) {
      k--;
    }

    // Interchange a[j] and a[k]

    temp = a[k];
    a[k] = a[j];
    a[j] = temp;

    // Put tail end of permutation after jth position in increasing order

    int r = a.length - 1;
    int s = j + 1;

    while (r > s) {
      temp = a[s];
      a[s] = a[r];
      a[r] = temp;
      r--;
      s++;
    }

    numLeft = numLeft.subtract(BigInteger.ONE);
    return a;
  }

  /**
   * @param n Argument
   * @return factorial of n
   */
  private static BigInteger getFactorial(int n) {
    BigInteger fact = BigInteger.ONE;
    for (int i = n; i > 1; i--) {
      fact = fact.multiply(new BigInteger(Integer.toString(i)));
    }
    return fact;
  }



  public static void main(String[] args) {
    if (args.length != 1) {
      System.err.println("Usage: java PermutationGenerator <n> (for n <= 20)\n");
      System.exit(1);
    }
    int n = Integer.parseInt(args[0]);
    if (n > 20) {
      System.err.println("n is too large!  Use n <= 20\n");
      System.exit(1);
    }
    PermutationGenerator pg = new PermutationGenerator(n);
    while (pg.hasNext()) {
      int[] a = pg.getNext();
      System.out.println(Arrays.toString(a));
    }
  }

}
