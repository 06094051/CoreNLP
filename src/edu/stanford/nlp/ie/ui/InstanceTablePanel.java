/*
 * InstanceTablePanel.java
 *
 * Created on March 5, 2003, 8:51 PM
 */

package edu.stanford.nlp.ie.ui;

import edu.stanford.nlp.ie.InstanceEventListener;
import edu.stanford.nlp.ie.SlotEventListener;

import javax.swing.*;
import javax.swing.table.AbstractTableModel;
import java.awt.*;
import java.util.*;

/**
 * Slot/value table for displaying an Instance in an ontology.
 *
 * @author Huy Nguyen
 */
public class InstanceTablePanel extends javax.swing.JPanel {

  /**
   * 
   */
  private static final long serialVersionUID = 5669739742742880922L;

  /**
   * Creates new form InstanceTablePanel
   */
  public InstanceTablePanel() {
    initComponents();
    instanceEventListeners = new ArrayList<InstanceEventListener>();
    slotEventListeners = new ArrayList<SlotEventListener>();
  }

  /**
   * This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  private void initComponents()//GEN-BEGIN:initComponents
  {
    buttonPanel = new javax.swing.JPanel();
    newInstanceButton = new javax.swing.JButton();
    instanceTableModel = new InstanceTableModel();
    JTable instanceTable = new JTable(instanceTableModel);
    instanceTable.setPreferredScrollableViewportSize(new Dimension(100, 100));
    tableScrollPane = new JScrollPane(instanceTable);

    setLayout(new java.awt.BorderLayout());

    buttonPanel.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT));

    newInstanceButton.setText("New Instance");
    newInstanceButton.setToolTipText("Create Instance");
    newInstanceButton.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        newInstanceButtonActionPerformed(evt);
      }
    });

    buttonPanel.add(newInstanceButton);

    add(buttonPanel, java.awt.BorderLayout.NORTH);

    add(tableScrollPane, java.awt.BorderLayout.CENTER);

  }//GEN-END:initComponents

  private void newInstanceButtonActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_newInstanceButtonActionPerformed
  {//GEN-HEADEREND:event_newInstanceButtonActionPerformed
    createInstance();
  }//GEN-LAST:event_newInstanceButtonActionPerformed


  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JScrollPane tableScrollPane;
  private javax.swing.JPanel buttonPanel;
  private javax.swing.JButton newInstanceButton;
  // End of variables declaration//GEN-END:variables
  private InstanceTableModel instanceTableModel;
  private ArrayList<InstanceEventListener> instanceEventListeners;
  private ArrayList<SlotEventListener> slotEventListeners;

  /* clears the table, and notifies instanceEventListeners that a new instance
   * has to be created
   */
  private void createInstance() {
    //instanceTableModel.clear();
    fireCreateInstance();
  }

  // HN TODO: maybe move all this update code to superclass.....
  public void addSlotEventListener(edu.stanford.nlp.ie.SlotEventListener listener) {
    slotEventListeners.add(listener);
  }

  public void removeSlotEventlistener(SlotEventListener listener) {
    slotEventListeners.remove(listener);
  }

  protected void fireSlotFilled(String slot, String value) {
    SlotEventListener listener;
    for (int i = 0; i < slotEventListeners.size(); i++) {
      listener = slotEventListeners.get(i);
      listener.slotFilled(slot, value);
    }
  }

  public void addInstanceEventListener(InstanceEventListener listener) {
    instanceEventListeners.add(listener);
  }

  public void removeInstanceEventListeners(InstanceEventListener listener) {
    instanceEventListeners.remove(listener);
  }

  protected void fireCreateInstance() {
    InstanceEventListener listener;
    for (int i = 0; i < instanceEventListeners.size(); i++) {
      listener = instanceEventListeners.get(i);
      listener.createInstance();
    }
  }

  /**
   * Sets the slots for the currently selected class
   */
  public void setSlotNames(Set<?> slotNames) {
    instanceTableModel.setSlotNames(slotNames);
  }

  /**
   * Sets the value of the given slot.
   */
  public void setSlotValue(String slotName, String slotValue) {
    instanceTableModel.setSlotValue(slotName, slotValue);
  }

  /**
   * Gets the value of the given slot.
   */
  public String getSlotValue(String slotName) {
    return instanceTableModel.getSlotValue(slotName);
  }

  /**
   * Sets all the slot values specified by given map
   */
  public void setSlotValues(Map<String, String> valuesBySlot) {
    instanceTableModel.setSlotValues(valuesBySlot);
  }

  /**
   * Gets all the slot values in the table.  Returns internal map
   */
  public Map<String, String> getSlotValues() {
    return instanceTableModel.getSlotValues();
  }

  private class InstanceTableModel extends AbstractTableModel {
    /**
     * 
     */
    private static final long serialVersionUID = -8549138409706624570L;
    private String[] names;
    private Object[] slotNames;
    private Map<String, String> valuesBySlot;

    public InstanceTableModel() {
      super();
      names = new String[]{"Slot", "Value"};
      valuesBySlot = new HashMap<String, String>();
    }

    @Override
    public String getColumnName(int col) {
      return names[col];
    }

    @Override
    public boolean isCellEditable(int row, int col) {
      return (col == 1); // only value cells are editable
    }

    public int getColumnCount() {
      return names.length;
    }

    public int getRowCount() {
      if (slotNames == null) {
        return 0;
      } else {
        return slotNames.length;
      }
    }

    public Object getValueAt(int row, int col) {
      if (row >= getRowCount()) {
        return (null);
      }
      String slotName = (String) slotNames[row];
      switch (col) {
        case 0:
          return slotName;
        case 1:
          return valuesBySlot.get(slotName);
        default:
          return (null);
      }
    }

    @Override
    public void setValueAt(Object value, int row, int col) {
      if (row < getRowCount()) {
        String valString = (value == null) ? null : value.toString();
        String slotName = (String) slotNames[row];
        switch (col) {
          case 1:
            // avoid infinite update loop
            // if both values are null, or the new value equals the old value
            if (!((value == null && valuesBySlot.get(slotName) == null) || (value != null && value.equals(valuesBySlot.get(slotName))))) {
              valuesBySlot.put(slotName, valString);
              fireTableCellUpdated(row, col);
              fireSlotFilled(slotName, valString);
            }
            break;
        }
      }
    }

    /**
     * Sets the slots for the currently selected class
     */
    @SuppressWarnings("unchecked") // Collections.sort is awful
    public void setSlotNames(Set<?> sn) {
      ArrayList slotNameList = new ArrayList(sn);
      Collections.sort(slotNameList);
      this.slotNames = slotNameList.toArray();
      fireTableDataChanged();
    }

    /**
     * Sets the value of the given slot.
     */
    public void setSlotValue(String slotName, String slotValue) {
      for (int r = 0; r < getRowCount(); r++) {
        if (slotName.equals(getValueAt(r, 0))) {
          setValueAt(slotValue, r, 1);
        }
      }
    }

    /**
     * Gets the value of the given slot.
     */
    public String getSlotValue(String slotName) {
      return valuesBySlot.get(slotName);
    }

    /**
     * Sets all the slot values specified by given map
     */
    public void setSlotValues(Map<String,String> valuesBySlot) {
      // iterate over the table entries instead of the map
      for (int r = 0; r < getRowCount(); r++) {
        String slotName = (String) getValueAt(r, 0);
        String slotValue = valuesBySlot.get(slotName);
        setValueAt(slotValue, r, 1);
      }
    }

    /**
     * Gets all the slot values in the table.  Returns internal map
     */
    public Map<String, String> getSlotValues() {
      return valuesBySlot;
    }

    /**
     * Clears the values in the table
     */
    public void clear() {
      Iterator<String> it = valuesBySlot.keySet().iterator();
      while (it.hasNext()) {
        String slot = it.next();
        setSlotValue(slot, "");
      }
    }
  }
}
